{"componentChunkName":"component---src-templates-template-tsx","path":"/dosubl-vs-call-execute/","result":{"data":{"site":{"meta":{"title":"Raw SAS - SAS Tips n Tricks","description":"Tips n Tricks and other SAS Titbits from around 10 years of SAS projects and tinkering about with SAS"}},"post":{"id":"54f6a232-80e6-536d-bf24-5820c31f5b22","html":"<p>Both <code>dosubl</code> and <code>call execute</code> accept raw SAS code as input.  The difference between them is that <code>call execute</code> will take your code and add it to the stack (so, after your data step completes) whilst <code>dosubl</code> will execute your code <em>immediately</em>.</p>\n<p>Dosubl is a fantastic function, which I use frequently, but after recently <a href=\"https://www.linkedin.com/feed/update/urn:li:activity:6334095623373099008?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A6334034113179242496%2C6334095608772726784%29\">lamenting it’s performance</a> I was asked - just how slow is it compared to call execute?</p>\n<p>Well of course the way to find out is to run some tests, which I did as per below.  I created a minimal data step, and switched off logging, and ran the exact same code twice:</p>\n<pre>options nonotes;\n/* dosubl */\ndata _null_;\n call symputx('start',datetime());\nrun;\ndata _null_;\n  do x=1 to 500;\n  rc=dosubl('data;do stuff=1;end;run;');\n  end;\nrun;\ndata _null_;\n  dur=datetime()-&amp;start;\n  call symputx('dosubl',dur);\nrun;\n\n/* call execute */\ndata _null_;\n  call symputx('start',datetime());\nrun;\ndata _null_;\n  do x=1 to 500;\n  call execute('data;do stuff=1;end;run;');\n  end;\nrun;\ndata _null_;\n  dur=datetime()-&amp;start;\n  call symputx('execute',dur);\nrun;\n%put &amp;=dosubl;\n%put &amp;=execute;\n</pre>\n<p>And the results?  Drum roll please…</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; margin-bottom: 1.0725rem;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 31.382978723404253%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABNElEQVQY03WQW2+CQBCF+f9/pU1ffalgi+WiCYhcRJBbH2ApasFATLByOruvrZNssjt7MnO+I33VDLtdiAn/16Xr6H+HQ5ygpfv3+Yw0SeB5Hg6HBHEUI6T/pjlioiESq0rouoG+H+j0uF6vuN1uGIYB9/uEY9NAnstQ1Q9UFUO038PZONg6W2zsDVzXg+e6KIpPGjhBKvIM8usciqLg6fkFsqyQyIVprlGVJdS3d9i2jeVSw9o0qG8iTXM8KqlmFULa+qg4omVZtMRH111QM0aYEYIgEA55XFEYCqen0wkSd+H7vng0hFezGm3bCfxxHMWAOSFzx3meizz5Ak3XYVs2sixHQf09meKRSFw0m82wWCygayaWqkpiA47joCwrITQMQzhar1bQNF1g+35AWf/8IfoF9Qq0LvHSnBIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Screen Shot 2017 11 16 at 01 12 39 300x94\" title=\"Screen Shot 2017 11 16 at 01 12 39 300x94\" src=\"/tetrahex-rawsas/static/e9728505ddb95b70b6fe31bc7d81949c/5a46d/Screen-Shot-2017-11-16-at-01.12.39-300x94.png\" srcset=\"/tetrahex-rawsas/static/e9728505ddb95b70b6fe31bc7d81949c/4dcb9/Screen-Shot-2017-11-16-at-01.12.39-300x94.png 188w,\n/tetrahex-rawsas/static/e9728505ddb95b70b6fe31bc7d81949c/5a46d/Screen-Shot-2017-11-16-at-01.12.39-300x94.png 300w\" sizes=\"(max-width: 300px) 100vw, 300px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>As per the log, dosubl finished in 47.6 seconds vs 3.7 seconds for call execute.  Lesson learned?  As useful and incredibly convenient as it is, <code>dosubl</code> is a function that should be used sparingly!</p>","frontmatter":{"title":"The Performance of Dosubl vs Call Execute","path":"/dosubl-vs-call-execute/","previewImg":null,"tags":["Programming","sas"],"date":"Nov 16, 2017"}}},"pageContext":{"archives":{"2012":8,"2013":10,"2014":4,"2015":7,"2016":17,"2017":12,"2018":9,"2019":2,"2020":3}}},"staticQueryHashes":[]}